from flask import Flask
import pandas as pd
from sqlalchemy import text
from flask_sqlalchemy import SQLAlchemy
import logging  # Para vermos o que acontece

# --- Configuração do App e Banco de Dados (Seu código, está perfeito) ---
app = Flask(__name__)

db_user = 'postgres'
db_pass = 'password'
db_host = 'localhost'
db_name = 'lightdb'
db_port = '5432'

app.config['SQLALCHEMY_DATABASE_URI'] = f'postgresql://{db_user}:{db_pass}@{db_host}:{db_port}/{db_name}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

# Configura o logging para vermos o progresso no console
logging.basicConfig(level=logging.INFO)


# --- Rotas da Aplicação ---

@app.route('/')
def index():
    return "<h1>Aplicação Flask de ETL da Light!</h1><p>Acesse /processar-etl-clientes para rodar a transformação.</p>"


@app.route('/adicionar-cidade-estado-clientes')
def processar_etl_clientes():
    """
    Rota de ETL: Lê as tabelas de clientes, local e estado,
    enriquece os clientes com o 'id_localizacao'
    e salva o resultado em uma nova tabela 'public.clientes_enriquecido'.
    """
    logging.info("Iniciando processo de ETL...")

    try:
        # --- 1. EXTRAÇÃO (E) ---
        logging.info("Lendo tabelas do banco de dados...")

        # Ajuste os nomes das tabelas aqui se estiverem diferentes
        query_clientes = text("SELECT * FROM public.clientes_bruto")
        query_local = text("SELECT * FROM public_analytics.dim_localizacao")
        query_estado = text("SELECT * FROM public_analytics.dim_estado")

        # Usamos db.engine para o Pandas se conectar
        with db.engine.connect() as conn:
            df_clientes = pd.read_sql(query_clientes, conn)
            df_local = pd.read_sql(query_local, conn)
            df_estado = pd.read_sql(query_estado, conn)

        logging.info(
            f"Dados carregados: {len(df_clientes)} clientes, {len(df_local)} locais, {len(df_estado)} estados.")

        # --- 2. TRANSFORMAÇÃO (T) ---
        logging.info("Iniciando transformação dos dados...")

        # Passo A: Criar o "Catálogo de Consulta" (Lookup)
        # Juntamos localizacao com estado para ter: [id_localizacao, cidade, id_estado, estado]
        catalogo_completo = pd.merge(df_local, df_estado, on='id_estado')

        # Passo B: Limpar o Catálogo (Regra de Negócio)
        # Removemos duplicatas da dimensão, garantindo que "Campos_RJ" só exista 1 vez.
        # Isso NÃO apaga clientes, apenas limpa nossa tabela de referência.
        lookup_limpo = catalogo_completo.drop_duplicates(subset=['cidade', 'estado'], keep='first')

        # Passo C: Enriquecer os Clientes
        # Juntamos os clientes (que têm 'cidade' e 'estado') com o lookup (que tem 'cidade', 'estado' e 'id_localizacao')
        df_clientes_enriquecido = pd.merge(
            df_clientes,
            lookup_limpo[['cidade', 'estado', 'id_localizacao']],  # Pegamos apenas as colunas necessárias do lookup
            on=['cidade', 'estado'],  # Chave da junção
            how='left'  # Mantém TODOS os clientes, mesmo se não achar o id (left join)
        )

        # Passo D: Criar a chave 'chave_estado_cidade_key' (Como você pediu)
        # Usamos .fillna('') para evitar erros se 'estado' ou 'cidade' forem nulos
        df_clientes_enriquecido['chave_estado_cidade_key'] = (
                df_clientes_enriquecido['estado'].fillna('') + "_" + df_clientes_enriquecido['cidade'].fillna('')
        )

        # Verificamos se algum cliente ficou sem id_localizacao
        clientes_sem_id = df_clientes_enriquecido['id_localizacao'].isna().sum()
        logging.info(
            f"Transformação concluída. {clientes_sem_id} clientes não encontraram um 'id_localizacao' correspondente.")

        # --- 3. CARGA (L) ---
        logging.info("Carregando dados transformados no banco de dados...")

        nome_tabela_nova = 'clientes_enriquecido'
        schema_nome = 'public'

        # Salva o DataFrame como uma nova tabela no banco de dados.
        # 'if_exists='replace'' significa que ela será recriada toda vez que você rodar.
        df_clientes_enriquecido.to_sql(
            nome_tabela_nova,
            db.engine,
            schema=schema_nome,
            if_exists='replace',
            index=False
        )

        logging.info("Processo de ETL concluído com sucesso!")

        return (
            f"<h1>ETL Concluído!</h1>"
            f"<p>A tabela <strong>{schema_nome}.{nome_tabela_nova}</strong> foi criada/atualizada com {len(df_clientes_enriquecido)} linhas.</p>"
            f"<p>{clientes_sem_id} clientes estão com 'id_localizacao' nulo (verificar mapeamento).</p>"
        )

    except Exception as e:
        logging.error(f"ERRO NO ETL: {e}")
        return f"<h1>Ocorreu um erro durante o ETL</h1><p>{e}</p>"


# --- Ponto de Entrada da Aplicação ---
if __name__ == '__main__':
    # Nós não precisamos do db.create_all() pois não estamos usando Modelos do SQLAlchemy
    app.run(debug=True)